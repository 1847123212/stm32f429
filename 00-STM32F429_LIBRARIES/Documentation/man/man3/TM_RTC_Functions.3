.TH "TM_RTC_Functions" 3 "Wed Mar 18 2015" "Version v1.0.0" "TM STM32F4xx Libraries" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TM_RTC_Functions \- TM_RTC_Functions
.PP
Library Functions\&.  

.SS "Functions"

.in +1c
.ti -1c
.RI "uint32_t \fBTM_RTC_Init\fP (\fBTM_RTC_ClockSource_t\fP source)"
.br
.RI "\fIInitializes RTC and starts counting\&. \fP"
.ti -1c
.RI "uint32_t \fBTM_RTC_GetUnixTimeStamp\fP (\fBTM_RTC_t\fP *data)"
.br
.RI "\fIGet number of seconds from date and time since 01\&.01\&.1970 00:00:00\&. \fP"
.ti -1c
.RI "void \fBTM_RTC_GetDateTimeFromUnix\fP (\fBTM_RTC_t\fP *data, uint32_t unix)"
.br
.RI "\fIGet formatted time from seconds till 01\&.01\&.1970 00:00:00 It fills struct with valid data\&. \fP"
.ti -1c
.RI "void \fBTM_RTC_Interrupts\fP (\fBTM_RTC_Int_t\fP int_value)"
.br
.RI "\fISelect RTC wakeup interrupts interval\&. \fP"
.ti -1c
.RI "\fBTM_RTC_Result_t\fP \fBTM_RTC_SetDateTime\fP (\fBTM_RTC_t\fP *data, \fBTM_RTC_Format_t\fP format)"
.br
.RI "\fISet date and time to internal RTC registers\&. \fP"
.ti -1c
.RI "\fBTM_RTC_Result_t\fP \fBTM_RTC_SetDateTimeString\fP (char *str)"
.br
.RI "\fISet date and time using string formatted date time\&. \fP"
.ti -1c
.RI "void \fBTM_RTC_GetDateTime\fP (\fBTM_RTC_t\fP *data, \fBTM_RTC_Format_t\fP format)"
.br
.RI "\fIGet date and time from internal RTC registers\&. \fP"
.ti -1c
.RI "uint8_t \fBTM_RTC_GetDaysInMonth\fP (uint8_t month, uint8_t year)"
.br
.RI "\fIGet number of days in month\&. \fP"
.ti -1c
.RI "uint16_t \fBTM_RTC_GetDaysInYear\fP (uint8_t year)"
.br
.RI "\fIGet number of days in specific year\&. \fP"
.ti -1c
.RI "void \fBTM_RTC_WriteBackupRegister\fP (uint8_t location, uint32_t value)"
.br
.RI "\fIWrite RTC backup register value\&. This method allows you to write 32bit value from backup register 0 - 18\&. \fP"
.ti -1c
.RI "uint32_t \fBTM_RTC_ReadBackupRegister\fP (uint8_t location)"
.br
.RI "\fIRead RTC backup register value\&. This method allows you to read 32bit value from backup register 0 - 18\&. \fP"
.ti -1c
.RI "void \fBTM_RTC_SetAlarm\fP (\fBTM_RTC_Alarm_t\fP Alarm, \fBTM_RTC_AlarmTime_t\fP *AlarmTime, \fBTM_RTC_Format_t\fP format)"
.br
.RI "\fIEnables alarm A or alarm B\&. \fP"
.ti -1c
.RI "void \fBTM_RTC_DisableAlarm\fP (\fBTM_RTC_Alarm_t\fP Alarm)"
.br
.RI "\fIDisables specific alarm\&. \fP"
.ti -1c
.RI "void \fBTM_RTC_RequestHandler\fP (void)"
.br
.RI "\fIRTC Wakeup handler function\&. Called when wakeup interrupt is triggered\&. \fP"
.ti -1c
.RI "void \fBTM_RTC_AlarmAHandler\fP (void)"
.br
.RI "\fIRTC Alarm A handler function\&. Called when interrupt is triggered for alarm B\&. \fP"
.ti -1c
.RI "void \fBTM_RTC_AlarmBHandler\fP (void)"
.br
.RI "\fIRTC Alarm B handler function\&. Called when interrupt is triggered for alarm B\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Library Functions\&. 


.SH "Function Documentation"
.PP 
.SS "void TM_RTC_AlarmAHandler (void)"

.PP
RTC Alarm A handler function\&. Called when interrupt is triggered for alarm B\&. 
.PP
\fBNote:\fP
.RS 4
Called from my RTC library 
.PP
With __weak parameter to prevent link errors if not defined by user 
.RE
.PP
\fBParameters:\fP
.RS 4
\fINone\fP 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void TM_RTC_AlarmBHandler (void)"

.PP
RTC Alarm B handler function\&. Called when interrupt is triggered for alarm B\&. 
.PP
\fBNote:\fP
.RS 4
Called from my RTC library 
.PP
With __weak parameter to prevent link errors if not defined by user 
.RE
.PP
\fBParameters:\fP
.RS 4
\fINone\fP 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void TM_RTC_DisableAlarm (\fBTM_RTC_Alarm_t\fP Alarm)"

.PP
Disables specific alarm\&. 
.PP
\fBParameters:\fP
.RS 4
\fIAlarm\fP Select which alarm you want to disable\&. This parameter can be a value of \fBTM_RTC_Alarm_t\fP enumeration 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void TM_RTC_GetDateTime (\fBTM_RTC_t\fP * data, \fBTM_RTC_Format_t\fP format)"

.PP
Get date and time from internal RTC registers\&. 
.PP
\fBParameters:\fP
.RS 4
\fI*data\fP Pointer to \fBTM_RTC_t\fP structure to save data to 
.br
\fIformat\fP Format of your structure\&. This parameter can be a value of \fBTM_RTC_Format_t\fP enumeration 
.RE
.PP

.SS "void TM_RTC_GetDateTimeFromUnix (\fBTM_RTC_t\fP * data, uint32_t unix)"

.PP
Get formatted time from seconds till 01\&.01\&.1970 00:00:00 It fills struct with valid data\&. 
.PP
\fBNote:\fP
.RS 4
Valid if year is greater or equal (>=) than 2000 
.RE
.PP
\fBParameters:\fP
.RS 4
\fI*data\fP Pointer to \fBTM_RTC_Time_t\fP struct to store formatted data in 
.br
\fIunix\fP Seconds from 01\&.01\&.1970 00:00:00 to calculate user friendly time 
.RE
.PP

.SS "uint8_t TM_RTC_GetDaysInMonth (uint8_t month, uint8_t year)"

.PP
Get number of days in month\&. 
.PP
\fBNote:\fP
.RS 4
This function also detects if it is leap year and returns different number for February 
.RE
.PP
\fBParameters:\fP
.RS 4
\fImonth\fP Month number in year, valid numbers are 1 - 12 
.br
\fIyear\fP Year number where you want to get days in month, last 2 digits 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fINumber\fP of days in specific month and year 
.RE
.PP

.SS "uint16_t TM_RTC_GetDaysInYear (uint8_t year)"

.PP
Get number of days in specific year\&. 
.PP
\fBNote:\fP
.RS 4
This function also detects if it is leap year 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIyear\fP Year number where you want to get days in month, last 2 digits 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIReturns\fP number of days in year 
.RE
.PP

.SS "uint32_t TM_RTC_GetUnixTimeStamp (\fBTM_RTC_t\fP * data)"

.PP
Get number of seconds from date and time since 01\&.01\&.1970 00:00:00\&. 
.PP
\fBParameters:\fP
.RS 4
\fI*data\fP Pointer to \fBTM_RTC_t\fP data structure 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fICalculated\fP seconds from date and time since 01\&.01\&.1970 00:00:00 
.RE
.PP

.SS "uint32_t TM_RTC_Init (\fBTM_RTC_ClockSource_t\fP source)"

.PP
Initializes RTC and starts counting\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsource\&.\fP RTC Clock source \fBTM_RTC_ClockSource_t\fP to be used for RTC 
.RE
.PP
\fBNote:\fP
.RS 4
Internal clock source is not so accurate 
.PP
If you reset your MCU and RTC still has power, it will count independent of MCU status 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIReturns\fP RTC status\&.
.IP "\(bu" 2
1: RTC has already been initialized and time is set
.IP "\(bu" 2
0: RTC was now initialized first time\&. Now you can set your first clock 
.PP
.RE
.PP

.SS "void TM_RTC_Interrupts (\fBTM_RTC_Int_t\fP int_value)"

.PP
Select RTC wakeup interrupts interval\&. 
.PP
\fBNote:\fP
.RS 4
This function can also be used to disable interrupt 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIint_value\fP Look for \fBTM_RTC_Int_t\fP for valid inputs 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "uint32_t TM_RTC_ReadBackupRegister (uint8_t location)"

.PP
Read RTC backup register value\&. This method allows you to read 32bit value from backup register 0 - 18\&. 
.PP
\fBNote:\fP
.RS 4
RTC has 20 backup registers where you can store data which will be available all the time RTC is running and has power\&.
.PP
My library uses register 19 to store info about RTC settings and is not available for USER to store data there\&.
.PP
RTC HAVE to be initialized first before you can use this method 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlocation\fP RTC backup register location\&. 0 to 18 are valid 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIValue\fP at specific RTC backup register location 
.RE
.PP

.SS "void TM_RTC_RequestHandler (void)"

.PP
RTC Wakeup handler function\&. Called when wakeup interrupt is triggered\&. 
.PP
\fBNote:\fP
.RS 4
Called from my RTC library 
.PP
With __weak parameter to prevent link errors if not defined by user 
.RE
.PP
\fBParameters:\fP
.RS 4
\fINone\fP 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void TM_RTC_SetAlarm (\fBTM_RTC_Alarm_t\fP Alarm, \fBTM_RTC_AlarmTime_t\fP * AlarmTime, \fBTM_RTC_Format_t\fP format)"

.PP
Enables alarm A or alarm B\&. 
.PP
\fBParameters:\fP
.RS 4
\fIAlarm\fP Specify which alarm to set\&. This parameter can be a value of \fBTM_RTC_Alarm_t\fP enumeration 
.br
\fI*AlarmTime\fP Pointer to \fBTM_RTC_AlarmTime_t\fP structure to get data from\&. 
.br
\fIformat\fP RTC date and time format\&. This parameter can be a value of \fBTM_RTC_Format_t\fP enumeration\&. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "\fBTM_RTC_Result_t\fP TM_RTC_SetDateTime (\fBTM_RTC_t\fP * data, \fBTM_RTC_Format_t\fP format)"

.PP
Set date and time to internal RTC registers\&. 
.PP
\fBParameters:\fP
.RS 4
\fI*data\fP Pointer to filled \fBTM_RTC_t\fP structure with date and time 
.br
\fIformat\fP Format of your structure\&. This parameter can be a value of \fBTM_RTC_Format_t\fP enumeration\&. 
.RE
.PP

.SS "\fBTM_RTC_Result_t\fP TM_RTC_SetDateTimeString (char * str)"

.PP
Set date and time using string formatted date time\&. 
.PP
\fBNote:\fP
.RS 4
Valid string format is: dd\&.mm\&.YY\&.x;HH:ii:ss
.IP "\(bu" 2
dd: date, 2 digits, decimal
.IP "\(bu" 2
mm: month, 2 digits, decimal
.IP "\(bu" 2
YY: year, last 2 digits, decimal
.IP "\(bu" 2
x: day in a week: 1 digit,
.IP "\(bu" 2
HH: hours, 24-hour mode, 2 digits, decimal
.IP "\(bu" 2
ii: minutes, 2 digits, decimal
.IP "\(bu" 2
ss: seconds, 2 digigs, decimal 
.PP
.RE
.PP
\fBParameters:\fP
.RS 4
\fI*str\fP Pointer to string with datetime format 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIRTC\fP datetime status \fBTM_RTC_Result_t\fP\&.
.IP "\(bu" 2
TM_RTC_Result_Ok: Date and Time set OK
.IP "\(bu" 2
TM_RTC_Result_Error: Date and time is wrong 
.PP
.RE
.PP

.SS "void TM_RTC_WriteBackupRegister (uint8_t location, uint32_t value)"

.PP
Write RTC backup register value\&. This method allows you to write 32bit value from backup register 0 - 18\&. 
.PP
\fBNote:\fP
.RS 4
RTC has 20 backup registers where you can store data which will be available all the time RTC is running and has power\&.
.PP
My library uses register 19 to store info about RTC settings and is not available for USER to store data there\&.
.PP
RTC HAVE to be initialized first before you can use this method 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlocation\fP RTC backup register location\&. 0 to 18 are valid 
.br
\fIvalue\fP 32-bit long value to be stored in RTC backup register 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIValue\fP at specific RTC backup register location 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for TM STM32F4xx Libraries from the source code\&.
