.TH "TM_USART" 3 "Wed Mar 18 2015" "Version v1.0.0" "TM STM32F4xx Libraries" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TM_USART \- TM_USART
.PP
TM USART Library for STM32F4xx - http://stm32f4-discovery.com/2014/04/library-04-connect-stm32f429-discovery-to-computer-with-usart/\&.  

.SS "Modules"

.in +1c
.ti -1c
.RI "\fBTM_USART_Macros\fP"
.br
.RI "\fIUSART default values for defines\&. \fP"
.ti -1c
.RI "\fBTM_USART_Typedefs\fP"
.br
.RI "\fIUSART Typedefs\&. \fP"
.ti -1c
.RI "\fBTM_USART_Functions\fP"
.br
.RI "\fIUSART Functions\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
TM USART Library for STM32F4xx - http://stm32f4-discovery.com/2014/04/library-04-connect-stm32f429-discovery-to-computer-with-usart/\&. 

\fBLibrary works for all 8 U(S)ARTs which are supported on STM32F4xx devices\&.\fP
.PP
\fBUSART receive interrupt handlers\fP
.RS 4

.RE
.PP
Every USART channel has it's own receive interrupt which stores incoming data into cyclic buffer\&. If you want to use your own receive handler, then you have to open defines\&.h files and set a define\&. 
.PP
.nf
//Use custom IRQ Receive handler
//Change X with possible U(S)ARTs: USART1, USART2, USART3, UART4, UART5, USART6, UART7, UART8
//#define TM_X_USE_CUSTOM_IRQ

.fi
.PP
 After you set define, you have to create a function, which will handle custom request 
.PP
.nf
//Change X with possible U(S)ARTs: USART1, USART2, USART3, UART4, UART5, USART6, UART7, UART8
//Parameter c is a received character
void TM_X_ReceiveHandler(uint8_t c) {
   //Do your stuff here when byte is received
}

.fi
.PP
 
.PP
\fBNote:\fP
.RS 4
If you use custom receive interrupt handler, then incoming data is not stored in internal buffer
.RE
.PP
\fBUSART Internal cyclic buffer\fP
.RS 4

.RE
.PP
In your project you can set internal cyclic buffer length, default is 32Bytes, with: 
.PP
.nf
//Set buffer sie for all buffers
#define TM_USART_BUFFER_SIZE number_of_bytes

.fi
.PP
 in your project's defines\&.h file\&. This will set default length for each buffer\&. So if you are working with F429 (it has 8 U(S)ARTs) then you will use 8kB RAM if you set define above to 1024\&.
.PP
As of version 2\&.0, you can now set different buffer sizes for different U(S)ARTs\&. If you don't change anything, then all USART's have buffer length of value, stored in \fCTM_USART_BUFFER_SIZE\fP define\&. If you want let's say just for USART1 to be 1kB, but others default value, you can add define below in defines\&.h file: 
.PP
.nf
//Buffer length for USART1 is 1kB, for others is still TM_USART_BUFFER_SIZE
#define TM_USART1_BUFFER_SIZE 1024

.fi
.PP
.PP
Other possible settings are (for other U(S)ARTs):
.IP "\(bu" 2
TM_USART1_BUFFER_SIZE
.IP "\(bu" 2
TM_USART2_BUFFER_SIZE
.IP "\(bu" 2
TM_USART3_BUFFER_SIZE
.IP "\(bu" 2
TM_UART4_BUFFER_SIZE
.IP "\(bu" 2
TM_UART5_BUFFER_SIZE
.IP "\(bu" 2
TM_USART6_BUFFER_SIZE
.IP "\(bu" 2
TM_UART7_BUFFER_SIZE
.IP "\(bu" 2
TM_UART8_BUFFER_SIZE
.PP
.PP
\fBPinout\fP 
.PP
.nf
             |PINSPACK 1     |PINSPACK 2     |PINSPACK 3    
U(S)ARTX     |TX     RX      |TX     RX      |TX     RX

USART1       |PA9    PA10    |PB6    PB7     |-      -
USART2       |PA2    PA3     |PD5    PD6     |-      -
USART3       |PB10   PB11    |PC10   PC11    |PD8    PD9
UART4        |PA0    PA1     |PC10   PC11    |-      -
UART5        |PC12   PD2     |-      -       |-      -
USART6       |PC6    PC7     |PG14   PG9     |-      -
UART7        |PE8    PE7     |PF7    PF6     |-      -
UART8        |PE1    PE0     |-      -       |-      -

.fi
.PP
.PP
In case these pins are not good for you, you can use TM_USART_PinsPack_Custom in function and callback function will be called, where you can initialize your custom pinout for your USART peripheral
.PP
\fBChange USART default operation modes\fP
.RS 4

.RE
.PP
In this section, you can change USART functionality\&. Do this only in case you know what are you doing!
.PP
Open \fBdefines\&.h\fP file, copy define you want to change and fill settings 
.PP
.nf
//Change X with possible U(S)ARTs: USART1, USART2, USART3, UART4, UART5, USART6, UART7, UART8
//Set flow control
#define TM_X_HARDWARE_FLOW_CONTROL      USART_HardwareFlowControl_None
//Set mode
#define TM_X_MODE                       USART_Mode_Tx | USART_Mode_Rx
//Set parity
#define TM_X_PARITY                     USART_Parity_No
//Set stopbits
#define TM_X_STOP_BITS                  USART_StopBits_1
//Set USART datasize
#define TM_X_WORD_LENGTH                USART_WordLength_8b

.fi
.PP
.PP
\fBChangelog\fP
.RS 4

.RE
.PP
.PP
.nf
 Version 2.3.1
   - March 17, 2015
   - Added support for Doxygen
   
 Version 2.3
   - March 14, 2015
   - Added support for STM32F446xx devices
   - Changed function name for custom pins initialization callback

 Version 2.2
   - March 10, 2015
   - Updated to be more independent of STD/HAL drivers but still not totally

 Version 2.1
   - March 08, 2015
   - Output pins are more clear initialized. 
   - TM GPIO library is now required to get USART to work properly

 Version 2.0
   - December 21, 2014
   - New cyclic buffer system,
      each U(S)ART can have different buffer size (less RAM can be used for USART purpose)
   - Added function to check if buffer is full,
   - TM_USART_Gets now returns 0 till '\n' is not available in buffer or buffer is full
      Useful for prevent infinite loop if '\n' never happen
      
 Version 1.0
   - First release
.fi
.PP
.PP
\fBDependencies\fP 
.PP
.PP
.nf
 - STM32F4xx
 - STM32F4xx RCC
 - STM32F4xx GPIO
 - STM32F4xx USART
 - attributes.h
 - defines.h
 - TM GPIO
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for TM STM32F4xx Libraries from the source code\&.
